# [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)


## 题目

一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：
```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，`"11106"` 可以映射为：

- `"AAJF"` ，将消息分组为 `(1 1 10 6)`
- `"KJF"` ，将消息分组为 `(11 10 6)`

**Example 1:**

```
输入：s = "12"

输出：2

解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

**Example 2:**

```
输入：s = "226"

输出：3

解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

## 题目大意

一条包含字母 A-Z 的消息通过以下方式进行了编码：

```c
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

给定一个只包含数字的非空字符串，请计算解码方法的总数。



## 解题思路

- 给出一个数字字符串，题目要求把数字映射成 26 个字母，映射以后问有多少种可能的翻译方法。
- 这题思路也是 DP。`dp[n]` 代表翻译长度为 n 个字符的字符串的方法总数。由于题目中的数字可能出现 0，0 不能翻译成任何字母，所以出现 0 要跳过。dp[0] 代表空字符串，只有一种翻译方法，`dp[0] = 1`。dp[1] 需要考虑原字符串是否是 0 开头的，如果是 0 开头的，`dp[1] = 0`，如果不是 0 开头的，`dp[1] = 1`。
- 当前位可能是从前一位 + 1位组合而成，也可能是从前两位 + 2位组合而成。那么状态转移方程就是 `dp[i] = dp[i - 2] + dp[i -1]`
- 如果是+1位生成的，要确保这一位不是0
- 如果是+2位生成的，要确保这两位在10～26范围内

- 与 `70. 爬楼梯` 题类似

## 代码

**Java版**

```java
class Solution {
    public int numDecodings(String s) {
        int[] dp = new int[s.length() + 1];
        dp[0] = 1;
        dp[1] = s.charAt(0) == '0' ? 0 : 1;
        for (int i = 2; i < dp.length; i++) {
            if (s.charAt(i - 1) != '0') {
                dp[i] += dp[i - 1];
            }
            if (s.charAt(i - 2) == '1' ||
                    (s.charAt(i - 2) == '2' && (s.charAt(i - 1) >= '0' && s.charAt(i - 1) <= '6'))) {
                dp[i] += dp[i - 2];
            }

        }
        return dp[s.length()];
    }
}
```

**Golang版**

```go
package leetcode

func numDecodings(s string) int {
	n := len(s)
	dp := make([]int, n+1)
	dp[0] = 1
	if s[0] == '0' {
		dp[1] = 0
	} else {
		dp[1] = 1
	}
	for i := 2; i <= n; i++ {
		if s[i-1] != '0' {
			dp[i] += dp[i-1]
		}
		if s[i-2] == '1' || (s[i-2] == '2' && (s[i-1] >= '0' && s[i-1] <= '6')) {
			dp[i] += dp[i-2]
		}
	}
	return dp[n]
}
```